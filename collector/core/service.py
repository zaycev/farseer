# -*- coding: utf-8 -*-import timeimport threadingimport multiprocessingimport loggingimport tracebackimport redisimport pickleclass Behavior(object):	PROC = 0	THREAD = 1class Service(object):	name = "service"	behavior_mode = Behavior.THREAD	logger_cls = None	main_loop_timeout = 2	send_timeout = 1	receive_timeout = 1	def __init__(self, *args, **kwargs):		self.mailbox = self.__class__.Mailbox(self, **kwargs)		self.logger_cls = logging.getLogger(self.name)	def run(self):		if self.behavior_mode == Behavior.PROC:			self.unit = multiprocessing.Process(				name=self.name,				target=lambda: self.__class__.service_loop(self)			)		elif self.behavior_mode == Behavior.THREAD:			self.unit = threading.Thread(				name=self.name,				target=lambda: self.__class__.service_loop(self)			)		self.init_mailbox(self.mailbox)		self.unit.daemon = True		self.unit.start()	class Mailbox(object):		def __init__(self, owner, **kwargs):			self.input_queue = None			self.output_queue = None			self.keeper = None			self.owner = owner			self.redis_connection = None	def send_task(self, task):		conn = self.mailbox.redis_connection		queue = self.mailbox.output_queue		while conn.llen(queue) >= 512:			time.sleep(self.send_timeout)#		print task		task_blob = pickle.dumps(task)		conn.lpush(queue, task_blob)#		if self.mailbox.output_queue:#			while self.mailbox.output_queue.full():#				time.sleep(self.send_timeout)#			try:#				self.mailbox.output_queue.put(task,#					False, self.send_timeout)#			except:#				time.sleep(self.send_timeout)#			finally:#				pass	def receive_task(self):		conn = self.mailbox.redis_connection		queue = self.mailbox.input_queue		if self.name == "worker.river_parser":			print self.mailbox.input_queue		while True:			if conn.llen(queue) > 0:				if self.name == "worker.river_parser":					print self.mailbox.input_queue				if self.name == "worker.river_parser":					print "try get blob"				task_blob = conn.rpop(queue)				if self.name == "worker.river_parser":					print "ok got"				if task_blob:					if self.name == "worker.river_parser":						print "try parse"					task = pickle.loads(task_blob)					if self.name == "worker.river_parser":						print "ok parser"					return task				else:					time.sleep(self.receive_timeout)			else:				if self.name == "worker.river_parser":					print "sleep"				time.sleep(self.receive_timeout)#		try:#			task = self.mailbox.input_queue.get(False,#				self.receive_timeout)#		finally:#			return task	def rollback(self, task):		conn = self.mailbox.redis_connection		queue = self.mailbox.input_queue		while conn.llen(queue) >= 512:			time.sleep(self.send_timeout * 2)		task_blob = pickle.dumps(task)		conn.lpush(queue, task_blob)#		fail_counter = task.fails_counter + 1#		if self.mailbox.input_queue:#			while self.mailbox.input_queue.full():#				time.sleep(self.send_timeout * 2)#			try:#				task.fails_counter = fail_counter#				self.mailbox.input_queue.put(task,#					False, self.send_timeout * 2)#			except:#				time.sleep(self.send_timeout * 2)#			finally:#				pass	def keep_task(self, task):		conn = self.mailbox.redis_connection		queue = self.mailbox.keeper		while conn.llen(queue) >= 512:			time.sleep(self.send_timeout * 2)		task_blob = pickle.dumps(task)		conn.lpush(queue, task_blob)#		if self.mailbox.keeper:#			while self.mailbox.keeper.full():#				time.sleep(self.send_timeout * 2)#			try:#				self.mailbox.keeper.put(task,#					False, self.send_timeout * 2)#			finally:#				pass	def service_loop(self):		raise NotImplementedError()	def target(self, task, **kwargs):		raise NotImplementedError()	def init_mailbox(self, mailbox, **kwargs):		pass	def log(self, message):		self.logger_cls.debug(message)class Worker(Service):	name = "worker"	def service_loop(self):		self.mailbox.redis_connection = redis.StrictRedis()		while True:			task = None			try:				task = self.receive_task()				if not task:					time.sleep(self.main_loop_timeout)				else:					result = self.target(task)					for new_task in result:						if new_task.is_correct():							self.send_task(new_task)						if self.mailbox.keeper:							self.keep_task(new_task)			except Exception:				log = [task, traceback.format_exc()]				self.log("main loop error while handling task\n{0}\n{1}".format(*log))				if task: self.rollback(task)	def target(self, task):		return [task]