# -*- coding: utf-8 -*-import timeimport rqueueimport loggingimport datetimeimport tracebackimport threadingimport multiprocessingclass Behavior(object):	PROC = 0	THREAD = 1class Service(object):	name = "service"	behavior_mode = Behavior.THREAD	logger_cls = None	main_loop_timeout = 5	max_wait_times = 32	immortal = False	def __init__(self, *args, **kwargs):		self.mailbox = self.__class__.Mailbox(self, **kwargs)		self.logger_cls = logging.getLogger(self.name)	def run(self):		if self.behavior_mode == Behavior.PROC:			self.unit = multiprocessing.Process(				name=self.name,				target=lambda: self.__class__.service_loop(self)			)			self.log("start proc {0}".format(self.name))		elif self.behavior_mode == Behavior.THREAD:			self.unit = threading.Thread(				name=self.name,				target=lambda: self.__class__.service_loop(self)			)			self.log("start thread {0}".format(self.name))		self.init_mailbox(self.mailbox)		self.unit.daemon = True		self.unit.start()	class Mailbox(object):		def __init__(self, owner, **kwargs):			self.input_queue = None			self.output_queues = []			self.owner = owner	def send_task(self, task):		for q in self.mailbox.output_queues:			q.put(task)	def receive_task(self):		return self.mailbox.input_queue.get()	def rollback(self, task):		self.mailbox.input_queue.put(task)	def service_loop(self):		raise NotImplementedError()	def target(self, task, **kwargs):		raise NotImplementedError()	def init_mailbox(self, mailbox, **kwargs):		pass	def before_loop(self):		pass	def log(self, message):		self.logger_cls.debug(message)class Worker(Service):	name = "worker"	def before_loop(self):		if self.behavior_mode is Behavior.PROC:			qpool = rqueue.QConnPool()			qpool.__init_agent__()	def service_loop(self):		self.before_loop()		self.mailbox.input_queue = self.mailbox.input_queue()		for i in xrange(0, len(self.mailbox.output_queues)):			self.mailbox.output_queues[i] = self.mailbox.output_queues[i]()		timeout_counter = 0		#it_is_first = False		while True:#: and timeout_counter < self.max_wait_times:			task = None			try:				task = self.receive_task()				if not task:#					if not it_is_first and not self.immortal:#						timeout_counter += 1					timeout_counter += 1					time.sleep(self.main_loop_timeout)					if timeout_counter > self.max_wait_times:						time.sleep(self.main_loop_timeout * 10)						timeout_counter = 0						self.log("{0} too much waitings, sleep for {1} secs".format(							self.name,							self.main_loop_timeout * 10)						)				else:					timeout_counter = 0					# it_is_first = False					start_time = datetime.datetime.now()					result = self.target(task)					end_time = datetime.datetime.now()					for new_task in result:						if new_task.is_correct():							task.job.meta.handle = (end_time - start_time).seconds							self.send_task(new_task)			except Exception:				log = [task, traceback.format_exc()]				self.log("main loop error while handling task\n{0}\n{1}".format(*log))				if task:					if task.job.meta.fails < task.max_fails:						task.job.meta.fails += 1						self.rollback(task)					else:						# task.job.meta.fails = 0						time.sleep(self.main_loop_timeout * 10)						self.log("{0} too much fails, sleep for {1} secs".format(							self.name,							self.main_loop_timeout * 10)						)						# self.rollback(task)					# else throw the task away	def target(self, task):		return [task]